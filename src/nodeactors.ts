import ws from 'ws';                                    //Import WebSocket
import { v4 as uuidv4 } from 'uuid';                    //Import UUID package
import cluster from 'cluster';                          //Node.js cluster
import process from 'process';                          //Node.js process

const actors: { [key: string]: Actor } = {};            //Object of actors
let workers: { [key: number]: any } = {};               //Object of workers
let primary = 0;                                        //Network number of spawner (if worker)
let yourNetworkNumber = 0;                              //Network number of this client
const remoteActors: { [key: string]: string } = {};

let network: any;                                       //WebSocket object

const events: { [key: string]: any } = {};              //Events object, used to queue events

//Create event listener
const on = (name: string, listener: Function) => {
    events[name] = listener;
}

//Remove event listener
const removeListener = (name: string) => {
    delete events[name];
}

//Emit event
const emit = (name: string) => {
    if (events[name])
        events[name]();
}

/**
 * state: The current state of the actor
 * message: The message the actor will process
 * self: The actor's self reference
 * 
 * This function will be passed by the programmer when spawning a new actor.
 * When processing a message, the actors framework will internally pass the state,
 * next message and self reference to the function and it is executed accordingly. 
 * The function code can take the form of any behaviour and is free to manipulate the 
 * state and message object accordingly
 */
interface ActorBehaviour {
    (state: object, message: object, self: ActorReference): void
}

//Actor object interface
interface Actor {
    name: string,                   //Actor name (identifies actor locally)
    state: { [key: string]: any },  //Actor maintained state
    behaviour: ActorBehaviour,      //Actor behaviour
    node: number,                   //Network number (identifies actor location over network)
    active: boolean                 //Whether actor is processing messages
}

//Actor facade interface
interface ActorReference {
    name: string,
    node: number
}

const messageHandler = (messageJson: any) => {
    switch (messageJson.header) {
        case "SPAWN":
            //The spawn message is received when a spawn request is sent
            const actor = spawn(messageJson.state, messageJson.behaviour);

            //Send a payload over the network with the local actor's name and network number
            //The actor ID generated by the sender is sent back so that they can identify that the specific actor has been spawned
            const payload = { header: "SPAWNED", to: messageJson.from, actualActorId: actor.name, remoteActorId: messageJson.remoteActorId };
            forward(payload);

            break;
        case "SPAWNED":
            //The spawned message is received as an acknowledgement by the remote node
            //The message includes the name of the remote node so that it can be uniquely identified
            remoteActors[messageJson.remoteActorId] = messageJson.actualActorId;

            //Emit to the event that a remote spawn acknowledgement has been received
            emit(messageJson.remoteActorId);
            break;
        case "MESSAGE":
            //A message addressed to a node that needs to be locally forwarded
            send(messageJson.actor, messageJson.message);
            break;
    }
}

/**
 * Establishes the connection with a WebSocket server which links other nodes hosting actors with an optional number of spawned cluster nodes
 * @param url The url to the WebSocket server
 * @param timeout The amount of time to wait for the server to allow for communication with other nodes
 * @param numWorkers The number of cluster nodes to spawn each of which will establish a connection with the server
 * @returns 
 */
const init = (url: string, timeout: number = 0x7fffffff, numWorkers: number = 0): Promise<object> => {
    //Establish connection with WebSocket server
    network = new ws(url);
    let readyMessage: any;

    return new Promise((resolve, reject) => {
        //Reject promise if timeout 
        setTimeout(reject, timeout);

        //Handle message from WebSocket server
        network.on('message', (message: Buffer) => {
            //Parse message
            const messageJson = JSON.parse(message.toString());

            switch (messageJson.header) {
                case "ACK": 
                    //The acknowledgement sent from the server when receiving a request
                    let exchanged = false;      //whether the set of network numbers have been exchanged between spawner and workers

                    if (cluster.isPrimary) {
                        //Primary node will fork the specified number of workers
                        for (let i = 0; i < numWorkers; i++) {
                            const worker = cluster.fork();
                            worker.on('message', (message: any) => {
                                //Logic if the initial exchange between spawner and worker is made
                                if (exchanged) {
                                    //Check if recipient of message is primary, if so handle the message
                                    if (message.to === messageJson.yourNetworkNumber)
                                        messageHandler(message);
                                    else
                                        //Forward message to respective worker node if the recipient of message is not primary
                                        forward(message);
                                }
                                else {
                                    //Logic if the initial exchange between spawner and worker has not been made  
                                    //Put worker object in object to keep track
                                    workers[message] = worker;

                                    if (Object.keys(workers).length === numWorkers) {
                                        //When all workers are connected, broadcast payload of the other worker network numbers
                                        //The workers will then keep note of these network numbers when choosing which communication link to use
                                        const payload = { primary: messageJson.yourNetworkNumber, workers };
                                        for (let id in workers)
                                            workers[id].send(payload);

                                        //Resolve promise as state has been exchanged with workers
                                        exchanged = true;
                                        resolve(readyMessage);
                                    }
                                }
                            })
                        }
                    } else {
                        //Worker node listens for message from primary
                        process.on('message', (message: any) => {
                            //If initial state has been exchanged, then any further messages are messages intended for actors residing in this client
                            if (exchanged)
                                messageHandler(message);
                            else {
                                //The first message received by the spawner is the network numbers of the spawner (primary) and all neighbouring processes
                                //If the worker needs to send a message to an actor residing in a neighbouring worker, send it to the primary node to handle forwarding
                                primary = message.primary;
                                workers = message.workers;

                                //Resolve promise as state has been exchanged with spawner (primary node)
                                exchanged = true;
                                resolve(readyMessage);
                            }
                        })
                    }
                    break;
                case "READY":
                    //This messages is broadcast by the WebSocket server when all clients are connected
                    yourNetworkNumber = messageJson.yourNetworkNumber;
                    if (cluster.isWorker)
                        //Send network number to the spawner. The spawner will keep track of each of the network numbers
                        //Once the spawner receives the network numbers of each of the spawned workers, it will broadcast them. 
                        //Every worker is made aware of its neighbours to choose IPC when possible
                        (<any>process).send(messageJson.yourNetworkNumber);

                    if (numWorkers === 0)
                        //If no workers have been spawned, simply resolve the Promise
                        resolve(messageJson);
                    else
                        //If workers have been spawned, store the ready message and resolve the Promise after exchanging network numbers with the workers
                        readyMessage = messageJson;
                    break;
                default:
                    //For any other message, handle it normally
                    messageHandler(messageJson);
                    break;
            }
        });
    })
}

/**
 * Closes the connection
 */
const closeConnection = () => {
    network.close();
    process.exit();
}

/**
 * Spawns a local actor
 * @param state The initial state of the actor
 * @param behaviour The behaviour of the actor in response to a message
 * @returns A reference to the spawned actor
 */
const spawn = (state: object, behaviour: ActorBehaviour | string): ActorReference => {
    const cleanedBehaviour = (typeof behaviour === "string") ?
        Function('init', 'spawn', 'spawnRemote', 'terminate', 'send', 'closeConnection', 'return ' + behaviour)(init, spawn, spawnRemote, terminate, send, closeConnection)
        : behaviour;

    //Generate unique name
    let name: string;
    do
        name = uuidv4();
    while (actors[name]);

    //Construct actor object and keep track of it in actors object
    const actor: Actor = { name, node: yourNetworkNumber, state, behaviour: cleanedBehaviour, active: true };
    actors[name] = actor;

    //Return actor reference
    return { name: actor.name, node: actor.node };
}

/**
 * Spawns an actor to a remote node
 * @param node The node referral number on the network
 * @param state The state to start the actor with
 * @param behaviour The behaviour of the actor when called
 * @param timeout How long to wait to receive an acknowledgement for the remotely spawned actor
 * @returns A promise which resolves into a reference to the remote actor
 */
const spawnRemote = (node: number, state: object, behaviour: ActorBehaviour, timeout: number = 0x7fffffff): Promise<ActorReference> => {
    return new Promise((resolve, reject) => {
        //Generate local name using UUIDv4
        const name = uuidv4();

        //Create payload to send over network. This will have the local name embedded
        const payload = { header: "SPAWN", to: node, remoteActorId: name, behaviour: behaviour.toString().trim().replace(/\n/g, ''), state };

        //Forward spawn request using the fastest available link
        forward(payload);

        //Create event listener waiting for an event named as the locally generated UUIDv4 name
        on(name, () => {
            if (remoteActors[name]){ 
                //Only execute once, remove listener immediately
                removeListener(name);

                //Resolve promise with the remotely generated actor name
                resolve({ name: remoteActors[name], node });            
            }
        });

        //Reject the promise if response takes too long
        setTimeout(() => { reject() }, timeout);
    })
}

/**
 * Sends a message object to a running actor.
 * @param actor The actor to send the message to
 * @param message The message object to send to an actor
 */
const send = (actor: ActorReference, message: object): void => {
    if (actor.node === yourNetworkNumber) {
        const localActor = actors[actor.name];
        //Local send
        if (localActor) {
            //Schedule message on the JavaScript event loop
            Promise.resolve().then(() => {
                if (message !== undefined && localActor.active)
                    localActor.behaviour(localActor.state, message, { name: localActor.name, node: localActor.node });
            })
        }
    } else {
        //Create network payload
        const payload = { header: "MESSAGE", actor, to: actor.node, message };
        forward(payload);
    }
}

/**
 * Forwards the payload using the optimal transport mechanism
 * @param payload The payload to send
 */
const forward = (payload: any): void => {
    const modifiedPayload = { from: yourNetworkNumber, ...payload };
    if (workers[payload.to] || payload.to === primary)
        //If it is one of the neighbouring cluster nodes...
        if (cluster.isPrimary)
            //Forward it to the right worker as a primary node
            workers[payload.to].send(modifiedPayload);
        else
            //Forward it to the primary node if you are a worker node
            (<any>process).send(modifiedPayload);
    else
        //If recipient is not part of the cluster, send over the network
        network.send(JSON.stringify(modifiedPayload));
}

/**
 * Terminates a local actor
 * @param actor The actor to terminate
 * @param force True to immediately stop the actor, false to let it process remaining messages and terminate safely
 */
const terminate = (actor: ActorReference, force: boolean = false) => {
    const localActor = actors[actor.name];

    //Check for the actor's existence
    if (localActor) {
        //Stop processing messages based on parameter
        localActor.active = !force;

        //Delete stored actor
        delete actors[actor.name];
    }
}

export default { init, spawn, spawnRemote, terminate, send, closeConnection };