Akka was built on the reactive manifesto which is a signed public declaration of the important aspects of reactive systems
@misc{reactivemanifesto,
  title={The Reactive Manifesto},
  author={Jonas Bonér, Dave Farley, Roland Kuhn and Martin Thompson},
  howpublished={https://www.reactivemanifesto.org/},
  note={Published: 2014-09-16, Accessed: 2022-03-17}
}

@misc{eventloopbrowser,
  title={The event loop},
  howpublished={https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop},
  note={Accessed: 2022-03-18}
}

@misc{eventloopnode,
  title={The Node.js Event Loop, Timers, and process.nextTick()},
  howpublished={https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/},
  note={Accessed: 2022-03-18}
}

@misc{nexttick,
  title={Understanding process.nextTick()},
  howpublished={https://nodejs.dev/learn/understanding-process-nexttick},
  note={Accessed: 2022-03-18}
}

ECMA-262 8th Edition Standard
@misc{es8,
  title={ECMAScript® 2017 Language Specification (ECMA-262, 8th edition, June 2017)},
  howpublished={https://262.ecma-international.org/8.0},
  note={Accessed: 2022-04-01}
}

@misc{scala,
  title={The Scala Programming Language},
  howpublished={https://www.scala-lang.org/},
  note={Accessed: 2022-04-03}
}

@misc{akka,
  title={akka},
  howpublished={https://akka.io/},
  note={Accessed: 2022-04-03}
}

@misc{elixir,
  title={elixir},
  howpublished={https://elixir-lang.org/},
  note={Accessed: 2022-04-03}
}

Shared Array Buffer which was introduced in ES8
@misc{sharedarraybuffer,
  title={SharedArrayBuffer},
  howpublished={https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global\_Objects/SharedArrayBuffer},
  note={Accessed: 2022-04-01}
}

@misc{cluster,
  title={Node.js v17.7.2 documentation},
  howpublished={https://nodejs.org/api/cluster.html},
  note={Accessed: 2022-03-19}
}

@misc{webworkers,
  title={Web Workers API},
  howpublished={https://developer.mozilla.org/Web/API/Web\_Workers\_API},
  note={Accessed: 2022-03-19}
}

Actor library by the chrome team
@misc{clooney,
  title={Clooney},
  howpublished={https://github.com/GoogleChromeLabs/clooney},
  note={Accessed: 2022-04-01}
}

Popular actor library
@misc{comedy,
  title={Comedy},
  howpublished={https://github.com/untu/comedy},
  note={Accessed: 2022-04-02}
}

Another popular actor library
@misc{drama,
  title={Drama},
  howpublished={https://github.com/stagas/drama},
  note={Accessed: 2022-04-02}
}

Industry used actor library
@misc{nact,
  title={Nact},
  howpublished={https://nact.xyz/},
  note={Accessed: 2022-04-01}
}

One of the first papers concretising the actor model for AI. Mostly mathematical and not very practical
@techreport{agha1985actors,
  title={Actors: A model of concurrent computation in distributed systems.},
  author={Agha, Gul A},
  year={1985},
  institution={Massachusetts Inst of Tech Cambridge Artificial Intelligence Lab}
}

@inproceedings{hewitt1973session,
  title={Session 8 formalisms for artificial intelligence a universal modular actor formalism for artificial intelligence},
  author={Hewitt, Carl and Bishop, Peter and Steiger, Richard},
  booktitle={Advance Papers of the Conference},
  volume={3},
  pages={235},
  year={1973},
  organization={Stanford Research Institute Menlo Park, CA}
}

A paper describing the efforts of porting the JVM Akka to JS. 
This project was built on scala-js-actor and is written to mimic JVM Akka code
@inproceedings{stivan2015akka,
  title={Akka. js: towards a portable actor runtime environment},
  author={Stivan, Gianluca and Peruffo, Andrea and Haller, Philipp},
  booktitle={Proceedings of the 5th International Workshop on Programming Based on Actors, Agents, and Decentralized Control},
  pages={57--64},
  year={2015}
}

An article proposing that all physically possible computation can be directly implemented using actors
Talks about how actors should be built. Embracing inconsistency and failure and performing on a best effort basis.
@article{hewitt2010actor,
  title={Actor model of computation: scalable robust information systems},
  author={Hewitt, Carl},
  journal={arXiv preprint arXiv:1008.1459},
  year={2010}
}

A very useful paper regarding the history of actors. 
It attempts to informally classify attributes that make up an actor system with respect to message processing, reception, state changes and actors per execution environment
@inproceedings{43years,
  title={43 years of actors: A taxonomy of actor models and their key properties},
  author={De Koster, Joeri and Van Cutsem, Tom and De Meuter, Wolfgang},
  booktitle={Proceedings of the 6th International Workshop on Programming Based on Actors, Agents, and Decentralized Control},
  pages={31--40},
  year={2016}
}

Paper comparing Scala Actors to Akka Actors, explaining the reason behind certain design decisions for these languages.
It talks about how programmers interface with actors in the two implementations as well as some challenges which the designs face.
It then talks about the sought after aspects of the actor runtime
@incollection{haller2012integration,
  title={On the integration of the actor model in mainstream technologies: the scala perspective},
  author={Haller, Philipp},
  publisher = {Association for Computing Machinery},
  booktitle={Proceedings of the 2nd edition on Programming systems, languages and applications based on actors, agents, and decentralized control abstractions},
  pages={1--6},
  year={2012}
}

Talks about  using JavaScript for high performance network programs
@article{highperformance,
  title={Node. js: Using JavaScript to build high-performance network programs},
  author={Tilkov, Stefan and Vinoski, Steve},
  journal={IEEE Internet Computing},
  volume={14},
  number={6},
  pages={80--83},
  year={2010},
  publisher={IEEE}
}

@techreport{haller2010isolated,
  title={Isolated actors for race-free concurrent programming},
  author={Haller, Philipp},
  year={2010},
  institution={EPFL}
}

@misc{ecmascript,
  title={Standard ECMA-262 - ECMAScript 2021 Language Specification},
  author={ECMA International},
  year={2021},
  howpublished={https://262.ecma-international.org/12.0/},
  note={Accessed: 2022-04-03}
}

Look into ECMAScript concurrency features, generators, await
@article{concurrencyjs,
  title={JavaScript Concurrency Models},
  author={Namiot, Dmitry and Sukhomlin, Vladimir},
  journal={International Journal of Open Information Technologies},
  volume={3},
  number={6},
  pages={21--24},
  year={2015}
}

Similar academic work
@inproceedings{spidersjs,
  title={Many spiders make a better web: a unified web-based actor framework},
  author={Myter, Florian and Scholliers, Christophe and De Meuter, Wolfgang},
  booktitle={Proceedings of the 6th International Workshop on Programming Based on Actors, Agents, and Decentralized Control},
  pages={51--60},
  year={2016}
}

Testing suite for the actor model
@inproceedings{savina,
author = {Imam, Shams M. and Sarkar, Vivek},
title = {Savina - An Actor Benchmark Suite: Enabling Empirical Evaluation of Actor Libraries},
year = {2014},
isbn = {9781450321891},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2687357.2687368},
doi = {10.1145/2687357.2687368},
booktitle = {Proceedings of the 4th International Workshop on Programming Based on Actors Agents \& Decentralized Control},
pages = {67–80},
numpages = {14},
keywords = {benchmark suite, actor model, java actor libraries, performance comparison},
location = {Portland, Oregon, USA},
series = {AGERE! '14}
}

Paper bringing parallelism to JavaScript without the use of actors
@article{tigerquoll,
  title={TigerQuoll: parallel event-based JavaScript},
  author={Bonetta, Daniele and Binder, Walter and Pautasso, Cesare},
  journal={ACM SIGPLAN Notices},
  volume={48},
  number={8},
  pages={251--260},
  year={2013},
  publisher={ACM New York, NY, USA}
}

@inproceedings{erlang,
author = {Armstrong, Joe},
title = {A History of Erlang},
year = {2007},
isbn = {9781595937667},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/1238844.1238850},
doi = {10.1145/1238844.1238850},
abstract = {Erlang was designed for writing concurrent programs that "run forever." Erlang uses concurrent processes to structure the program. These processes have no shared memory and communicate by asynchronous message passing. Erlang processes are lightweight and belong to the language, not the operating system. Erlang has mechanisms to allow programs to change code "on the fly" so that programs can evolve and change as they run. These mechanisms simplify the construction of software for implementing non-stop systems.This paper describes the history of Erlang. Material for the paper comes from a number of different sources. These include personal recollections, discussions with colleagues, old newspaper articles and scanned copies of Erlang manuals, photos and computer listings and articles posted to Usenet mailing lists.},
booktitle = {Proceedings of the Third ACM SIGPLAN Conference on History of Programming Languages},
pages = {6–1–6–26},
location = {San Diego, California},
series = {HOPL III}
}